#!/usr/bin/perl -w
#!/usr/bin/perl -d:ptkdb -w
#

use strict;


BEGIN
{
    push @INC, '.';

    push @INC, '/usr/local/glue/swig/perl';
}


use Data::Dumper;

use Heccer;

use Neurospaces;


$SIG{__DIE__}
    = sub {
	use Carp;

	confess @_;
    };

$ENV{NEUROSPACES_MODELS} = '/local_home/local_home/hugo/neurospaces_project/neurospaces/source/c/snapshots/0/library';


sub main
{
    # construct a translation service

    my $neurospaces = Neurospaces::NeurospacesNew();

    # read a model

    # my $args = [ "$0", "-P", "cells/golgi.ndf" ];

    my $args = [ "$0", "-P", "cells/purk2m9s.ndf" ];

    my $success = Neurospaces::NeurospacesRead($neurospaces, $#$args + 1, $args);

    # instantiate a scheduler

    my $scheduler
	= SSP->new(
		   {
# 		    models => [
# 			       [ "$0", "-P", "segments/purkinje_maind_passive.ndf" ],
# 			      ],
		    models => [
			       {
				modelname => "/Purkinje",
				solverclass => "Heccer",
			       },
			      ],
		    service => SSP::Service->new(
						 {
						  backend => $neurospaces,
						 },
						),
		    solverclasses => {
				      Heccer => {
						 constructor => "SwiggableHeccer::HeccerConstruct",
						},
				     },
		   },
		  );

    # compile the schedule

    my $setup = $scheduler->setup();

    if (!$setup)
    {
	die "Failed to compile a schedule";
    }

    # advance the time

    $scheduler->advance(0.1);
}


main();


exit 0;


# packages below

package SSP;


sub advance
{
    my $self = shift;

    my $time = shift;

    # set default result : ok

    my $result = 1;

    # loop over all schedulees

    my $schedule = $self->{schedule};

    foreach my $schedulee (@$schedule)
    {
	# advance the engine

	my $error = $schedulee->advance($time);

	if ($error)
	{
	    die "Scheduling for $time failed";
	}
    }

    # return result

    return $result;
}


sub new
{
    my $package = shift;

    my $options = shift;

    my $self
	= {
	   %$options,
	  };

    bless $self, $package;

    return $self;
}


sub setup
{
    my $self = shift;

    # set default result : ok

    my $result = 1;

    # construct a schedule

    my $schedule = $self->{schedule} || [];

    # loop over all models

    my $models = $self->{models};

    foreach my $model (@$models)
    {
	# instantiate a schedulee

	my $modelname = $model->{modelname};

	my $solverclass = $model->{solverclass};

	my $service = $self->{service};

	my $engine = SSP::Engine->new($solverclass, $service, $modelname);

	# compile the model

	if (!$engine->compile($self))
	{
	    return 0;
	}

	# register the schedulee in the schedule

	push @$schedule, $engine;
    }

    # register the schedule

    $self->{schedule} = $schedule;

    # return result

    return $result;
}


package SSP::Glue;



sub backend
{
    my $self = shift;

    return $self->{backend};
}


package SSP::Engine;


BEGIN { our @ISA = qw(SSP::Glue); }


sub advance
{
    my $self = shift;

    my $time = shift;

    # set result : ok

    my $result;

    my $backend = $self->backend();

    my $success = $backend->HeccerHeccs($time);

    if (!$success)
    {
	$result = "HeccerHeccs() failed";
    }

    # return result

    return $result;
}


sub compile
{
    my $self = shift;

    my $scheduler = shift;

    # set default result : ok

    my $result = 1;

    #t do better error checking for this method

    # construct an engine for this model

    my $modelname = $self->{modelname};

    my $solverclass = $self->{solverclass};

    my $constructor = $scheduler->{solverclasses}->{$solverclass}->{constructor};

    my $service = $self->{service};

    my $service_backend = $service->backend();

    my $engine;

    {
	no strict "refs";

	$engine = &$constructor($service_backend, $modelname);
    }

    # register the engine with the schedulee

    $self->{backend} = $engine;

    # tell the engine to use the service to build the intermediary

    #t use the Heccer.pm methods here.

    $engine->HeccerCompileP1();

    # build indices for optimization

    $engine->HeccerCompileP2();

    # compile to byte code

    $engine->HeccerCompileP3();

    # initiate values

    $engine->HeccerInitiate();

#     # initial dump

#     #! should be diagnostics really

#     $engine->HeccerDumpV();

    # return result

    return $result;
}


sub new
{
    my $package = shift;

    my $solverclass = shift;

    my $service = shift;

    my $modelname = shift;

    my $self
	= {
	   modelname => $modelname,
	   service => $service,
	   solverclass => $solverclass,
	  };

    bless $self, $package;

    return $self;
}


package SSP::Service;


BEGIN { our @ISA = qw(SSP::Glue); }


sub new
{
    my $package = shift;

    my $options = shift;

    my $self = { %$options, };

    bless $self, $package;

    return $self;
}


