#!/usr/bin/perl -w
#!/usr/bin/perl -d:ptkdb -w
#

use strict;


$| = 1;


BEGIN
{
    #! make check

    push @INC, '../perl';

    #! make distcheck

    push @INC, '../../perl';

    #! normal run

    push @INC, './perl';

    #! after install

    push @INC, '/usr/local/glue/swig/perl';
}


use Getopt::Long;

use SSP;

use YAML;


$SIG{__DIE__}
    = sub {
	use Carp;

	confess @_;
    };


my $option_configuration_cell;
my $option_daemonize;
my $option_debug;
my $option_emit_output = [];
my $option_emit_schedules;
my $option_inject_delay;
my $option_inject_duration;
my $option_inject_magnitude;
my $option_model_directory;
my $option_model_filename;
my $option_model_name;
my $option_neurospaces_models = '/usr/local/neurospaces/models/library';
my $option_neurospaces_studio;
my $option_output_fields = [];
my $option_parameters = [];
my $option_set_name;
my $option_set_outputclass_filename;
my $option_solverclass = 'heccer';
my $option_spine_prototype;
my $option_steps;
my $option_time = 0.050;
my $option_time_step;
my $option_transformator = "";
our $option_verbose;

my $exit_code = 0;


my $builtin_configurations
    = {
       cell => {
		apply => {
			  simulation => [
					 {
					  arguments => [ 0, { verbose => $option_verbose, }, ],
					  method => 'steps',
					 },
					],
			 },
		usage => '
	Simulate a single model neuron, default is to output the membrane potential of the soma.
	Use the options to inject current in the soma (--inject-magnitude).
	The model\'s soma segment must reside in a SEGMENT_GROUP with name "segments".

        The name of the model neuron is inferred from the name of the model description file.
        (e.g. a model description file called "hh_neuron.ndf" is assumed to define a model neuron
        called "hh_neuron").

	--model-name overwrite the default model name.
	--steps sets number of steps
',
	       },
      };


sub apply_settings
{
    my $scheduler = shift;

    my $settings = shift;

    # loop over all services

    my $services = $scheduler->{services};

    foreach my $service_name (keys %$services)
    {
	my $service = $services->{$service_name};

	# if this is the neurospaces service

	if ($service->{module_name} eq 'Neurospaces')
	{
	    # if the library option is set

	    if (defined $option_neurospaces_models)
	    {
		# set the option for the service

		$service->{model_library} = $option_neurospaces_models;
	    }
	}
    }
}


sub execute
{
    my $filename = shift;

    my $options = shift;

    # if the configuration exists

    if (-e $filename)
    {
	# construct schedule from the configuration

	my $scheduler;

	eval
	{
	    local $/;

	    $scheduler = Load(`cat "$filename"`);
	};

	if ($@)
	{
	    print "$0: scheduler cannot be constructed from '$filename': $@, ignoring this schedule\n";

	    return;
	}

	# fill in the name of the schedule

	if ($options->{inherit_name})
	{
	    $scheduler->{name} = $filename;
	}

	# fill in the name of the output class

	if ($options->{inherit_outputclass})
	{
	    # loop over all output classes

	    my $outputclasses = $scheduler->{outputclasses};

	    foreach my $outputclass_name (keys %$outputclasses)
	    {
		# start with schedule filename

		my $outputname = $filename;

		# remove all directory names

		$outputname =~ s(.*/)();

		# remove possible .yml extension, gives output filename

		$outputname =~ s(\.yml$)()i;

		# we assume all output is directed to an output directory

		$outputname = "./output/$outputname";

		# fill in output class

		$outputclasses->{$outputclass_name}->{options}->{filename} = $outputname;
	    }
	}

	# and run it

	schedule($scheduler);
    }
    else
    {
	print STDERR "$0: configuration $filename cannot be found\n";

	$exit_code = 1;
    }
}


sub main
{
    read_cmd_line();

    # loop over all configurations

    foreach my $configuration (@ARGV)
    {
	# execute the configuration

	execute
	    (
	     $configuration,
	     {
	      inherit_name => $option_set_name,
	      inherit_outputclass => $option_set_outputclass_filename,
	     },
	    );
    }

    # if using one of the builtin configurations

    if ($option_configuration_cell)
    {
# 	if (!defined $option_model_filename)
# 	{
# 	    system "$0 --help";

# 	    die "option_model_name must be set when using the 'cell' builtin configuration without a filename";
# 	}

# 	if (!defined $option_model_filename)
# 	{
# 	    system "$0 --help";

# 	    die "option_model_filename must be set when using a builtin configuration";
# 	}

	if (!defined $option_model_filename)
	{
	    $option_model_filename = $option_configuration_cell;
	}

	if (!defined $option_model_name)
	{
	    $option_model_filename =~ m((.*)\.(ndf|p|swc))i;

	    $option_model_name = $1;

	    $option_model_name =~ s(.*/)();

	    if (!defined $option_model_name)
	    {
		system "$0 --help";

		die "option_model_name cannot be determined from the option_model_filename due to a regex mismatch, bailing out";
	    }

	    if ($option_verbose)
	    {
		print "Inferring model name from $option_model_filename, model name set to $option_model_name\nUse the --model-name option to overwrite\n";
	    }
	}

	# construct a schedule from a builtin

	use Clone qw(clone);

	my $scheduler = clone($builtin_configurations->{cell});

	# assign name

	$scheduler->{name} = "builtin cell configuration, applied to: $option_model_name";

	# process service options

	my $services
	    = {
	       neurospaces => {
			       module_name => 'Neurospaces',
			      },
	      };

	# if this is a neurospaces .ndf file

	if  ($option_model_filename =~ m(\.ndf$))
	{
	    # use the 'read' method to initialize the model container

	    my $args = [ "$0", "-P", ];

	    push @$args, $option_model_filename;

	    $services->{neurospaces}->{initializers}
		= [
		   {
		    arguments => [ $args, ],
		    method => 'read',
		   },
		  ];
	}

	# else a true morphology file

	else
	{
	    # use the 'load' method to initializer the model container

	    #! this will also convert .p and .swc files respecting the
	    #! conversion library.

	    my $args = [ "$0", "-P", ];

	    $services->{neurospaces}->{initializers}
		= [
		   {
		    arguments => [
				  {
				   filename => $option_model_filename,
				   spine_prototype => $option_spine_prototype,
				  },
				  $args,
				 ],
		    method => 'load',
		   },
		  ];

	}

	$scheduler->{services} = $services;

	# infer the model name

	my $model_root = $option_model_name;

	# add an initial slash to the model name if necessary

	if ($model_root !~ m|^/|)
	{
	    print "add an initial slash to the model name if necessary $model_root\n";

	    $model_root = "/$model_root";
	}

	# link model name with solver class

	my $models
	    = [
	       {
		modelname => $model_root,
		solverclass => $option_solverclass,
	       },
	      ];

	# no conceptual parameters, has been obsoleted

# 	my $conceptual_parameters
# 	    = [
# 	       {
# 		component_name => 'thickd::gaba::/Purk_GABA',
# 		description => 'endogenous activity',
# 		field => 'FREQUENCY',
# 		value => '1',
# 	       },
# 	       {
# 		component_name => 'spine::/Purk_spine/head/par',
# 		description => 'endogenous activity',
# 		field => 'FREQUENCY',
# 		value => '25',
# 	       },
# 	      ];

# 	$models->[0]->{conceptual_parameters} = $conceptual_parameters;

	# fill in granular parameters for this model

	my $granular_parameters;

	if ($option_inject_magnitude
	   and !$option_inject_delay
	   and !$option_inject_duration)
	{
	    $granular_parameters
		= [
		   {
		    component_name => "$model_root/segments/soma",
		    field => 'INJECT',
		    value => $option_inject_magnitude,
		   },
		  ];
	}
	else
	{
	    $granular_parameters
		= [
		  ];
	}

	$granular_parameters
	    = [
	       @$granular_parameters,
	       map
	       {
		   my $setting = $_;

		   $setting =~ m/^(.*)->(.*)=(.*)$/;

		   my $component_name = $1;

		   my $field = $2;

		   my $value = $3;

		   my $result
		       = {
			  component_name => $component_name,
			  field => $field,
			  value => $value,
			 };

		   $result;
	       }
	       @$option_parameters,
	      ];

	$models->[0]->{granular_parameters} = $granular_parameters;

	# fill in the model section of the schedule

	$scheduler->{models} = $models;

	# define the solver class

	my $option_solverclass_name = 'Heccer';

	my $solverclasses
	    = {
	       heccer => {
# 			  constructor_settings => {
# 						   dStep => (2e-5),
# 						   configuration => {
# 								     reporting => {
# 										   granularity => 1000,
# 										   tested_things => (
# 												     $SwiggableHeccer::HECCER_DUMP_VM_COMPARTMENT_MATRIX
# 												     | $SwiggableHeccer::HECCER_DUMP_VM_COMPARTMENT_DATA
# 												     | $SwiggableHeccer::HECCER_DUMP_VM_COMPARTMENT_OPERATIONS
# 												     | $SwiggableHeccer::HECCER_DUMP_VM_MECHANISM_DATA
# 												     | $SwiggableHeccer::HECCER_DUMP_VM_MECHANISM_OPERATIONS
# 												     | $SwiggableHeccer::HECCER_DUMP_VM_SUMMARY
# 												    ),
# 										  },
# 								    },
# 						  },
			  module_name => $option_solverclass_name,
			  service_name => 'neurospaces',
			 },
	      };

	if (defined $option_time_step)
	{
	    $solverclasses->{heccer}->{constructor_settings}->{dStep} = $option_time_step;
	}

	# fill in solver class in the schedule

	$scheduler->{solverclasses} = $solverclasses;

	# define an output filename

	my $option_output_directory = './output';

	my $option_output_filename = $option_output_directory . $model_root . ".out";

	# create the directory for the output file

	$option_output_filename =~ m((.*)/);

	my $directory = $1;

	if ($1)
	{
	    `mkdir -p "$1"`;
	}

	# we assume the solver exports a suitable output class

	#! not sure if this is a good idea

	my $option_output_package = $option_solverclass_name . '::' . 'Output';

	# assemble output class definition

	my $outputclasses
	    = {
	       double_2_ascii => {
				  module_name => $option_solverclass_name,
				  options => {
					      filename => $option_output_filename,
					     },
				  package => $option_output_package,
				 },
	      };

	# fill in the output class in the schedule

	$scheduler->{outputclasses} = $outputclasses;

	# link the model outputs with the output class

	if (!@$option_output_fields)
	{
	    $option_output_fields = [ "$model_root/segments/soma->Vm", ];
	}

	my $outputs
	    = [
	       map
	       {
		   my $address = $_;

		   if ($address !~ m/^(.*)->(.*)$/)
		   {
		       die "$0: unknown output specification $address.  Output specifications must be in the format 'component_name'->'field_name' (eg. --output '/Purkinje/segments/soma->Vm')";
		   }

		   my $component_name = $1;

		   my $field = $2;

		   my $result
		       = {
			  component_name => $component_name,
			  field => $field,
			  outputclass => 'double_2_ascii',
			 };

		   $result;
	       }
	       @$option_output_fields,
	      ];

	$scheduler->{outputs} = $outputs;

	# set the apply options

	# set verbosity level

	my $apply
	    = {
	       simulation => [
			      {
			       arguments => [ 0, { verbose => 0, }, ],
			       method => 'steps',
			      },
			     ],
	      };

	my $apply_time
	    = {
	       simulation => [
			      {
			       arguments => [ 0, { verbose => 0, }, ],
			       method => 'advance',
			      },
			     ],
	      };

	if (defined $option_verbose)
	{
	    $apply->{simulation}->[0]->{arguments}->[1]->{verbose} = $option_verbose;
	}

	# setting the number of steps cannot be combined with inject duration and delay

	if (defined $option_steps
	    and (defined $option_inject_delay or defined $option_inject_duration))
	{
	    die "$0: option inject-delay and option inject-duration cannot be combined with option steps";
	}

	# set number of steps

	if (defined $option_steps)
	{
	    $apply->{simulation}->[0]->{arguments}->[0] = $option_steps;
	}

	# set simulation time

	if (defined $option_time)
	{
	    if (not defined $option_inject_delay and not defined $option_inject_duration)
	    {
		$apply_time->{simulation}->[0]->{arguments}->[0] = $option_time;
	    }
	    else
	    {
		if (!defined $option_inject_delay)
		{
		    $option_inject_delay = 0;
		}

		my $time_termination = $option_time - $option_inject_delay - $option_inject_duration;

		$apply_time
		    = {
		       simulation => [
				      {
				       arguments => [ $option_inject_delay, { verbose => 0, }, ],
				       method => 'advance',
				      },
				      {
				       arguments => [
						     {
						      component_name => "$model_root/segments/soma",
						      field => 'INJECT',
						      modelname => "$model_root",
						      value => $option_inject_magnitude,
						     },
						    ],
				       method => 'apply_granular_parameters',
				      },
				      {
				       arguments => [ $option_inject_duration, { verbose => 0, }, ],
				       method => 'advance',
				      },
				      {
				       arguments => [
						     {
						      component_name => "$model_root/segments/soma",
						      field => 'INJECT',
						      modelname => "$model_root",
						      value => 0,
						     },
						    ],
				       method => 'apply_granular_parameters',
				      },
				      {
				       arguments => [ $time_termination, { verbose => 0, }, ],
				       method => 'advance',
				      },
				     ],
		      };
	    }
	}

	defined $option_steps
	    ? $scheduler->{apply} = $apply
		: $scheduler->{apply} = $apply_time;

	# dump the schedule

	if ($option_verbose)
	{
	    print Dump("Running schedule") . Dump($scheduler);
	}

	# and run it

	schedule($scheduler);
    }

    # now emit all the output files

    if ($option_verbose)
    {
	print "\noutput files follow\n---\n";
    }

    foreach my $emit_output (@$option_emit_output)
    {
	system "cat", $emit_output;
    }

}


sub read_cmd_line
{
    my $option_builtins;
    my $option_help;
    my $option_version;

    my $result
	= GetOptions
	    (
	     "builtins!" => \$option_builtins,
	     "cell=s" => \$option_configuration_cell,
	     "daemonize!" => \$option_daemonize,
	     "debug=s" => \$option_debug,
	     "emit-output=s" => $option_emit_output,
	     "emit-schedules!" => \$option_emit_schedules,
	     "help!" => \$option_help,
	     "inject-delay=s" => \$option_inject_delay,
	     "inject-duration=s" => \$option_inject_duration,
	     "inject-magnitude=s" => \$option_inject_magnitude,
	     "model-directory=s" => \$option_model_directory,
	     "model-filename=s" => \$option_model_filename,
	     "model-name=s" => \$option_model_name,
	     "neurospaces-models=s" => \$option_neurospaces_models,
	     "neurospaces-studio" => \$option_neurospaces_studio,
	     "output-fields=s" => $option_output_fields,
	     "parameters=s" => $option_parameters,
	     "set-name=s" => \$option_set_name,
	     "set-outputclass-filename=s" => \$option_set_outputclass_filename,
	     "solverclass=s" => \$option_solverclass,
	     "spine-prototype=s" => \$option_spine_prototype,
	     "steps=i" => \$option_steps,
	     "time=s" => \$option_time,
	     "time-step=s" => \$option_time_step,
	     "transformator=s" => \$option_transformator,
	     "v|verbose+" => \$option_verbose,
	     "version" => \$option_version,
	    );

    if ($option_version)
    {
	my $version = SSP::version();

	print $version . "\n";

	exit 1;
    }

    if ($option_help
	|| !@ARGV
	&& !$option_builtins
	&& !$option_configuration_cell)
    {
	print
	    "
$0 <configuration>

$0: run simulations, given an ssp configuration, or using a builtin configuration

try $0 --builtins for information of how to run a simulation easily

options:
    builtins           give help about supported builtin configurations.
    cell               use the cell builtin configuration.
    daemonize          detach from terminal, close shared resources and run in the background,
                       note that this option currently inhibits any feedback of the process,
                       so be cautious with it.
    debug              set to a string of the debugging package, 1 for a default of SSP::Debug.
    emit-output        files to write to stdout after the simulation finishes.
    emit-schedules     print schedules to stdout instead of running them.
    help               print usage information.
    inject-magnitude   amount of current injected into the soma.
    model-directory    name of the directory where to look for non-std models.
    model-filename     filename of the model description file (when using a builtin configuration).
    model-name         name of the model (when using a builtin configuration).
    neurospaces-models directory where to find the neurospaces library.
    neurospaces-studio replace the simulation routine with calls to the neurospaces studio,
                       this allows to explore the model after all modifiers have completed.
    outputs            define an output, can be given multiple times.
    parameters         set a specific parameter value, can be given multiple times.
    set-name           overwrite the schedule name with the name of the file that contains the schedule.
    set-outputclass-filename
                       overwrite the outputclass filename with something derived from the name of the
                       file that contains the schedule.
    solverclass        set the solver class to use (when using a builtin configuration).
    spine-prototype    add spines with this prototype.
    steps              number of simulation steps, when using one of the builtin configurations.
    time               set simulation time (in seconds).
    time-step          sets the time step, when using one of the builtin configurations.
    transformator      feed the configuration through this transformator before running.
    verbose            set verbosity level.
";

	exit 1;
    }

    if ($option_builtins)
    {
	print
	    "
$0 <configuration>

$0: run simulations, given an ssp configuration, or using a builtin configuration

Known builtin configurations:

";

	foreach my $builtin_configuration_name (keys %$builtin_configurations)
	{
	    print "\n$builtin_configuration_name:\n\n";

	    print $builtin_configurations->{$builtin_configuration_name}->{usage};

	}

	print "\n";

	exit 1;
    }

}


sub schedule
{
    my $scheduler = shift;

    {
	# if option to replace the simulation routine with calls to the neurospaces studio

	if ($option_neurospaces_studio)
	{
	    # load things related to the neurospaces studio

	    #! for proper error reporting of loading modules (Renderer etc),
	    #! 'require' must be used, not 'use'.

	    require Neurospaces;
	    require Neurospaces::Traversal;
	    require Neurospaces::Studio;

	    #! this comes later in the neurospaces script, no clue why

	    require Neurospaces::GUI;

	    # replace the simulation routine

	    $scheduler->{apply}->{simulation}
		= [
		   {
		    arguments => [ $0, ],
		    method => 'Neurospaces::GUI::gui',
		   },
		  ];

	    # remove the compilation and initiation parts, to prevent
	    # that output files get overwritten

	    $scheduler->{apply}->{initializers} = [ undef, ];
	}

	# if option to daemonize

	if ($option_daemonize)
	{
	    # we tell to add the daemonizing call to the current initializers

	    $scheduler->{apply}->{initializers}
		= {
		   push => [
			    {
			     #! arguments: close_files, options hash

			     #! only STDIN, STDOUT, STDERR, because I think some of the GUI
			     #! things have potentially already opened filehandles, or so.
			     #! simply closing all filehandles inhibits the GUI when used
			     #! invocated from the webserver.

			     arguments => [ 2, ],
			     method => 'daemonize',
			    },
			   ],
		   have => $scheduler->{apply}->{initializers},
		   type => 'push',
		  };
	}
    }

    # determine the package name of the scheduler

    my $package_name = "SSP";

    if ($option_debug)
    {
	$package_name = $option_debug;

	if ($package_name eq 1)
	{
	    $package_name = "SSP::Debug";
	}
    }

    # now check if we indeed have a valid scheduler from that package name

    use UNIVERSAL qw( isa can );

    if (!isa($scheduler, $package_name))
    {
	# no, construct one

	$scheduler = $package_name->new( { %$scheduler, verbose => $option_verbose, }, );
    }

    # apply the local settings

    my $settings
	= {
	   neurospaces_models => $option_neurospaces_models,
	  };

    apply_settings($scheduler, $settings);

    # serialize the schedule

    my $serialized_schedule = Dump($scheduler);

    use IO::File;

    my $fh = IO::File->new(">/tmp/current_schedule");

    if ($fh)
    {
	print $fh $serialized_schedule;

	$fh->close();
    }

    # if options say to emit the schedule

    if ($option_emit_schedules)
    {
	# emit the schedule

	print Dump($scheduler);
    }

    # else

    else
    {
	# run the schedule

	if ($option_verbose)
	{
	    print "$0: Running schedule $scheduler->{name}\n";
	}

	$scheduler->run();
    }

}


main();


exit $exit_code;


