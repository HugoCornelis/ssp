#!/usr/bin/perl -w
#!/usr/bin/perl -d:ptkdb -w
#

use strict;


$| = 1;


BEGIN
{
    #! make check

    push @INC, '../perl';

    #! normal run

    push @INC, './perl';

    #! after install

    push @INC, '/usr/local/glue/swig/perl';
}


use Getopt::Long;

use SSP;

use YAML;


$SIG{__DIE__}
    = sub {
	use Carp;

	confess @_;
    };


my $option_configuration_cell;
my $option_help;
my $option_model_filename;
my $option_model_name;
my $option_neurospaces_models = '/local_home/local_home/hugo/neurospaces_project/neurospaces/source/c/snapshots/0/library';
my $option_solverclass = 'heccer';
my $option_steps = 2500;
my $option_transformator = "";
my $option_verbose;


my $args = [ "$0", "-P", "" ];


my $configurations
    = {
       cell => {
		apply => {
			  simulation => [
					 {
					  arguments => [ 0, { verbose => $option_verbose, }, ],
					  method => 'steps',
					 },
					],
			 },
		services => {
			     neurospaces => {
					     initializers => [
							      {
							       arguments => [ $#$args + 1, $args, ],
							       method => 'read',
							      },
							     ],
					     module_name => 'Neurospaces',
					    },
			    },
	       },
      };

sub apply_settings
{
    my $scheduler = shift;

    my $settings = shift;

    # loop over all services

    my $services = $scheduler->{services};

    foreach my $service_name (keys %$services)
    {
	my $service = $services->{$service_name};

	# if this is the neurospaces service

	if ($service->{module_name} eq 'Neurospaces')
	{
	    # if the library option is set

	    if (defined $option_neurospaces_models)
	    {
		# set the option for the service

		$service->{model_library} = $option_neurospaces_models;
	    }
	}
    }
}


sub main
{
    read_cmd_line();

    # loop over all configurations

    foreach my $configuration (@ARGV)
    {
	# if the configuration exists

	if (-e $configuration)
	{
	    # construct schedule from the configuration

	    local $/;

	    my $scheduler = Load(`cat $configuration`);

	    # and run it

	    schedule($scheduler);
	}
	else
	{
	    print STDERR "$0: configuration $configuration cannot be found\n";
	}
    }

    # if using one of the builtin configurations

    if ($option_configuration_cell)
    {
	if (!defined $option_model_name)
	{
	    system "$0 --help";

	    die "option_model_name must be set when using a builtin configuration";
	}

	my $model_root = $option_model_name;

	# construct a schedule from a builtin

	use Clone qw(clone);

	my $scheduler = clone($configurations->{cell});

	# assign name

	$scheduler->{name} = "cell configuration: $model_root";

	# process service options

	my $services
	    = {
	       neurospaces => {
			       initializers => [
						{
						 arguments => [ $#$args + 1, $args, ],
						 method => 'read',
						},
					       ],
			       module_name => 'Neurospaces',
			      },
	      };

	if (!defined $option_model_filename)
	{
	    system "$0 --help";

	    die "option_model_filename must be set when using a builtin configuration";
	}

	$services->{neurospaces}->{initializers}->[0]->{arguments}->[1]->[$#$args] = $option_model_filename;

	$scheduler->{services} = $services;

	# process model options

	my $models
	    = [
	       {
		modelname => "/$option_model_name",
		solverclass => $option_solverclass,
	       },
	      ];

	my $granular_parameters
	    = [
	       {
		component_name => "/$model_root/segments/soma",
		field => 'INJECT',
		value => 2e-9,	# 0,
	       },
	      ];

	$models->[0]->{granular_parameters} = $granular_parameters;

	$scheduler->{models} = $models;

	# process solver class options

	my $option_solverclass_name = 'Heccer';

	my $solverclasses
	    = {
	       heccer => {
# 			  constructor_settings => {
# 						   dStep => (2e-5),
# 						   configuration => {
# 								     reporting => {
# 										   granularity => 1000,
# 										   tested_things => (
# 												     $SwiggableHeccer::HECCER_DUMP_VM_COMPARTMENT_MATRIX
# 												     | $SwiggableHeccer::HECCER_DUMP_VM_COMPARTMENT_DATA
# 												     | $SwiggableHeccer::HECCER_DUMP_VM_COMPARTMENT_OPERATIONS
# 												     | $SwiggableHeccer::HECCER_DUMP_VM_MECHANISM_DATA
# 												     | $SwiggableHeccer::HECCER_DUMP_VM_MECHANISM_OPERATIONS
# 												     | $SwiggableHeccer::HECCER_DUMP_VM_SUMMARY
# 												    ),
# 										  },
# 								    },
# 						  },
			  module_name => $option_solverclass_name,
			  service_name => 'neurospaces',
			 },
	      };

	$scheduler->{solverclasses} = $solverclasses;

	# process output class options

	my $option_output_directory = './output';

	my $option_output_filename = $option_output_directory . '/' . $option_model_name;

	$option_output_filename =~ m((.*)/);

	my $directory = $1;

	if ($1)
	{
	    `mkdir -p "$1"`;
	}

	my $option_output_package = $option_solverclass_name . '::' . 'Output';

	my $outputclasses
	    = {
	       double_2_ascii => {
				  module_name => $option_solverclass_name,
				  options => {
					      filename => $option_output_filename,
					     },
				  package => $option_output_package,
				 },
	      };

	$scheduler->{outputclasses} = $outputclasses;

	# process output options

	my $outputs
	    = [
	       {
		component_name => "/$model_root/segments/soma",
		field => 'Vm',
		outputclass => 'double_2_ascii',
	       },
	      ];

	$scheduler->{outputs} = $outputs;

	# set the apply options

	# set verbosity level

	my $apply
	    = {
	       simulation => [
			      {
			       arguments => [ 0, { verbose => 0, }, ],
			       method => 'steps',
			      },
			     ],
	      };

	if (defined $option_verbose)
	{
	    $apply->{simulation}->[0]->{arguments}->[1]->{verbose} = $option_verbose;
	}

	# set number of steps

	if (defined $option_steps)
	{
	    $apply->{simulation}->[0]->{arguments}->[0] = $option_steps;
	}

	$scheduler->{apply} = $apply;

	# and run it

	schedule($scheduler);
    }
}


sub read_cmd_line
{
    my $result
	= GetOptions
	    (
	     "cell!" => \$option_configuration_cell,
	     "help!" => \$option_help,
	     "model-filename=s" => \$option_model_filename,
	     "model-name=s" => \$option_model_name,
	     "neurospaces-models=s" => \$option_neurospaces_models,
	     "solverclass=s" => \$option_solverclass,
	     "steps=i" => \$option_steps,
	     "transformator=s" => \$option_transformator,
	     "v|verbose+" => \$option_verbose,
	    );

    if ($option_help)
    {
	print
	    "
$0 <configuration>

$0: run simulations, given an ssp configuration, or using a builtin configuration

options :
    cell               use the cell builtin configuration
    help               print usage information.
    model-filename     filename of the model description file (when using a builtin configuration)
    model-name         name of the model (when using a builtin configuration)
    neurospaces-models directory where to find the neurospaces library
    solverclass        set the solver class to use (when using a builtin configuration)
    steps              number of simulation steps
    transformator      feed the configuration through this transformator before running
    verbose            set verbosity level.
";

	exit 1;
    }

}


sub schedule
{
    my $scheduler = shift;

    use UNIVERSAL qw( isa can );

    if (!isa($scheduler, "SSP"))
    {
	$scheduler = SSP->new($scheduler);
    }

    # apply the local settings

    my $settings
	= {
	   neurospaces_models => $option_neurospaces_models,
	  };

    apply_settings($scheduler, $settings);

    # run the schedule

    $scheduler->run( { verbosity => $option_verbose, }, );

}


main();


exit 0;


