#!/usr/bin/perl -w
#!/usr/bin/perl -d:ptkdb -w
#

use strict;


$| = 1;


BEGIN
{
    #! make check

    push @INC, '../perl';

    #! make distcheck

    push @INC, '../../perl';

    #! normal run

    push @INC, './perl';

    #! after install

    push @INC, '/usr/local/glue/swig/perl';
}


use Getopt::Long;

use SSP;

use YAML;


$SIG{__DIE__}
    = sub {
	use Carp;

	confess @_;
    };


my $option_configuration_cell;
my $option_emit_schedules;
my $option_inject_soma;
my $option_model_directory;
my $option_model_filename;
my $option_model_name;
my $option_neurospaces_models = '/usr/local/neurospaces/models/library';
my $option_set_name;
my $option_set_outputclass_filename;
my $option_solverclass = 'heccer';
my $option_spine_prototype;
my $option_steps = 2500;
my $option_time_step;
my $option_transformator = "";
my $option_verbose;


my $builtin_configurations
    = {
       cell => {
		apply => {
			  simulation => [
					 {
					  arguments => [ 0, { verbose => $option_verbose, }, ],
					  method => 'steps',
					 },
					],
			 },
		usage => '
	Simulate a cell, default is to output the membrane potential of the soma.
	A current injection of 2e-9 is given (unless overwritten using the options).
	The soma segment must reside in a SEGMENT_GROUP with name "segments".

	--model-filename set the model filename, and filename of the output file.
	--steps sets number of steps
',
	       },
      };

sub apply_settings
{
    my $scheduler = shift;

    my $settings = shift;

    # loop over all services

    my $services = $scheduler->{services};

    foreach my $service_name (keys %$services)
    {
	my $service = $services->{$service_name};

	# if this is the neurospaces service

	if ($service->{module_name} eq 'Neurospaces')
	{
	    # if the library option is set

	    if (defined $option_neurospaces_models)
	    {
		# set the option for the service

		$service->{model_library} = $option_neurospaces_models;
	    }
	}
    }
}


sub execute
{
    my $filename = shift;

    my $options = shift;

    # if the configuration exists

    if (-e $filename)
    {
	# construct schedule from the configuration

	my $scheduler;

	eval
	{
	    local $/;

	    $scheduler = Load(`cat "$filename"`);
	};

	if ($@)
	{
	    print "$0: scheduler cannot be constructed from '$filename': $@, ignoring this schedule\n";

	    return;
	}

	# fill in the name of the schedule

	if ($options->{inherit_name})
	{
	    $scheduler->{name} = $filename;
	}

	# fill in the name of the output class

	if ($options->{inherit_outputclass})
	{
	    my $outputclasses = $scheduler->{outputclasses};

	    foreach my $outputclass_name (keys %$outputclasses)
	    {
		my $outputname = $filename;

		$outputname =~ s(.*/)();

		$outputname =~ s(\.yml$)()i;

		$outputname = "./output/$outputname";

		$outputclasses->{$outputclass_name}->{options}->{filename} = $outputname;
	    }
	}

	# and run it

	schedule($scheduler);
    }
    else
    {
	print STDERR "$0: configuration $filename cannot be found\n";
    }
}


sub main
{
    read_cmd_line();

    # loop over all configurations

    foreach my $configuration (@ARGV)
    {
	# execute the configuration

	execute
	    (
	     $configuration,
	     {
	      inherit_name => $option_set_name,
	      inherit_outputclass => $option_set_outputclass_filename,
	     },
	    );
    }

    # if using one of the builtin configurations

    if ($option_configuration_cell)
    {
	if (!defined $option_model_name
	    && !defined $option_model_filename)
	{
	    system "$0 --help";

	    die "option_model_name must be set when using the 'cell' builtin configuration without a filename";
	}

	if (!defined $option_model_filename)
	{
	    system "$0 --help";

	    die "option_model_filename must be set when using a builtin configuration";
	}

	if (!defined $option_model_name)
	{
	    $option_model_filename =~ m(.*/?([^/]*)\.(ndf|p));

	    $option_model_name = $1;

	    if (!defined $option_model_name)
	    {
		system "$0 --help";

		die "option_model_name cannot be determined from the option_model_filename due to a regex mismatch, bailing out";
	    }
	}

	# construct a schedule from a builtin

	use Clone qw(clone);

	my $scheduler = clone($builtin_configurations->{cell});

	# assign name

	$scheduler->{name} = "cell configuration: $option_model_name";

	# process service options

	my $services
	    = {
	       neurospaces => {
			       module_name => 'Neurospaces',
			      },
	      };

	# if this is a genesis .p file

	if ($option_model_filename =~ m(\.p$))
	{
	    my $args = [ "$0", "-P", ];

	    $services->{neurospaces}->{initializers}
		= [
		   {
		    arguments => [
				  {
				   filename => $option_model_filename,
				   spine_prototype => $option_spine_prototype,
				  },
				  $args,
				 ],
		    method => 'load',
		   },
		  ];

	}
	else
	{
	    my $args = [ "$0", "-P", ];

	    push @$args, $option_model_filename;

	    $services->{neurospaces}->{initializers}
		= [
		   {
		    arguments => [ $args, ],
		    method => 'read',
		   },
		  ];
	}

	$scheduler->{services} = $services;

	# process model options

	my $model_root = $option_model_name;

	my $models
	    = [
	       {
		modelname => "/$option_model_name",
		solverclass => $option_solverclass,
	       },
	      ];

	my $conceptual_parameters
	    = [
	       {
		component_name => 'thickd::gaba::/Purk_GABA',
		description => 'endogenous activity',
		field => 'FREQUENCY',
		value => '1',
	       },
	       {
		component_name => 'spine::/Purk_spine/head/par',
		description => 'endogenous activity',
		field => 'FREQUENCY',
		value => '25',
	       },
	      ];

# 	$models->[0]->{conceptual_parameters} = $conceptual_parameters;

	my $granular_parameters;

	if ($option_inject_soma)
	{
	    $granular_parameters
		= [
		   {
		    component_name => "/$model_root/segments/soma",
		    field => 'INJECT',
		    value => $option_inject_soma,
		   },
		  ];
	}
	else
	{
	    $granular_parameters
		= [
		   {
		    component_name => "/$model_root/segments/soma",
		    field => 'INJECT',
		    value => 2e-9, # 0,
		   },
		  ];
	}

	$models->[0]->{granular_parameters} = $granular_parameters;

	$scheduler->{models} = $models;

	# process solver class options

	my $option_solverclass_name = 'Heccer';

	my $solverclasses
	    = {
	       heccer => {
# 			  constructor_settings => {
# 						   dStep => (2e-5),
# 						   configuration => {
# 								     reporting => {
# 										   granularity => 1000,
# 										   tested_things => (
# 												     $SwiggableHeccer::HECCER_DUMP_VM_COMPARTMENT_MATRIX
# 												     | $SwiggableHeccer::HECCER_DUMP_VM_COMPARTMENT_DATA
# 												     | $SwiggableHeccer::HECCER_DUMP_VM_COMPARTMENT_OPERATIONS
# 												     | $SwiggableHeccer::HECCER_DUMP_VM_MECHANISM_DATA
# 												     | $SwiggableHeccer::HECCER_DUMP_VM_MECHANISM_OPERATIONS
# 												     | $SwiggableHeccer::HECCER_DUMP_VM_SUMMARY
# 												    ),
# 										  },
# 								    },
# 						  },
			  module_name => $option_solverclass_name,
			  service_name => 'neurospaces',
			 },
	      };

	if (defined $option_time_step)
	{
	    $solverclasses->{heccer}->{constructor_settings}->{dStep} = $option_time_step;
	}

	$scheduler->{solverclasses} = $solverclasses;

	# process output class options

	my $option_output_directory = './output';

	my $option_output_filename = $option_output_directory . '/' . $option_model_name;

	$option_output_filename =~ m((.*)/);

	my $directory = $1;

	if ($1)
	{
	    `mkdir -p "$1"`;
	}

	my $option_output_package = $option_solverclass_name . '::' . 'Output';

	my $outputclasses
	    = {
	       double_2_ascii => {
				  module_name => $option_solverclass_name,
				  options => {
					      filename => $option_output_filename,
					     },
				  package => $option_output_package,
				 },
	      };

	$scheduler->{outputclasses} = $outputclasses;

	# process output options

	my $outputs
	    = [
	       {
		component_name => "/$model_root/segments/soma",
		field => 'Vm',
		outputclass => 'double_2_ascii',
	       },
	      ];

	$scheduler->{outputs} = $outputs;

	# set the apply options

	# set verbosity level

	my $apply
	    = {
	       simulation => [
			      {
			       arguments => [ 0, { verbose => 0, }, ],
			       method => 'steps',
			      },
			     ],
	      };

	if (defined $option_verbose)
	{
	    $apply->{simulation}->[0]->{arguments}->[1]->{verbose} = $option_verbose;
	}

	# set number of steps

	if (defined $option_steps)
	{
	    $apply->{simulation}->[0]->{arguments}->[0] = $option_steps;
	}

	$scheduler->{apply} = $apply;

	# dump the schedule

	print Dump("Running schedule") . Dump($scheduler);

	# and run it

	schedule($scheduler);
    }
}


sub read_cmd_line
{
    my $option_builtins;
    my $option_help;

    my $result
	= GetOptions
	    (
	     "builtins!" => \$option_builtins,
	     "cell!" => \$option_configuration_cell,
	     "emit-schedules!" => \$option_emit_schedules,
	     "help!" => \$option_help,
	     "inject-soma=s" => \$option_inject_soma,
	     "model-directory=s" => \$option_model_directory,
	     "model-filename=s" => \$option_model_filename,
	     "model-name=s" => \$option_model_name,
	     "neurospaces-models=s" => \$option_neurospaces_models,
	     "set-name=s" => \$option_set_name,
	     "set-outputclass-filename=s" => \$option_set_outputclass_filename,
	     "solverclass=s" => \$option_solverclass,
	     "spine-prototype=s" => \$option_spine_prototype,
	     "steps=i" => \$option_steps,
	     "time-step=s" => \$option_time_step,
	     "transformator=s" => \$option_transformator,
	     "v|verbose+" => \$option_verbose,
	    );

    if ($option_help
	|| !@ARGV
	&& !$option_builtins
	&& !$option_configuration_cell)
    {
	print
	    "
$0 <configuration>

$0: run simulations, given an ssp configuration, or using a builtin configuration

try $0 --builtins for information of how to run a simulation easily

options :
    builtins           give help about supported builtin configurations
    cell               use the cell builtin configuration
    emit-schedules     print schedules to stdout instead of running them.
    help               print usage information.
    inject-soma        amount of current injected into the soma.
    model-directory    name of the directory where to look for non-std models
    model-filename     filename of the model description file (when using a builtin configuration)
    model-name         name of the model (when using a builtin configuration)
    neurospaces-models directory where to find the neurospaces library
    set-name           overwrite the schedule name with the name of the file that contains the schedule
    set-outputclass-filename
                       overwrite the outputclass filename with something derived from the name of the
                       file that contains the schedule
    solverclass        set the solver class to use (when using a builtin configuration)
    spine-prototype    add spines with this prototype
    steps              number of simulation steps
    time-step          sets the time step
    transformator      feed the configuration through this transformator before running
    verbose            set verbosity level.
";

	exit 1;
    }

    if ($option_builtins)
    {
	print
	    "
$0 <configuration>

$0: run simulations, given an ssp configuration, or using a builtin configuration

Known builtin configurations:

";

	foreach my $builtin_configuration_name (keys %$builtin_configurations)
	{
	    print "\n$builtin_configuration_name:\n\n";

	    print $builtin_configurations->{$builtin_configuration_name}->{usage};

	}

	print "\n";

	exit 1;
    }

}


sub schedule
{
    my $scheduler = shift;

    use UNIVERSAL qw( isa can );

    if (!isa($scheduler, "SSP"))
    {
	$scheduler = SSP->new($scheduler);
    }

    # apply the local settings

    my $settings
	= {
	   neurospaces_models => $option_neurospaces_models,
	  };

    apply_settings($scheduler, $settings);

    # serialize the schedule

    my $serialized_schedule = Dump($scheduler);

    use IO::File;

    my $fh = IO::File->new(">/tmp/current_schedule");

    print $fh $serialized_schedule;

    $fh->close();

    # if options say to emit the schedule

    if ($option_emit_schedules)
    {
	# emit the schedule

	print Dump($scheduler);
    }

    # else

    else
    {
	# run the schedule

	if ($option_verbose)
	{
	    print "$0: Running schedule $scheduler->{name}\n";
	}

	$scheduler->run( { verbosity => $option_verbose, }, );
    }

}


main();


exit 0;


